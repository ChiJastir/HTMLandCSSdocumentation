{
  "translation": {
    "settings": "Настройки",
    "theme": "Тема",
    "language": "Язык",
    "menuPin": "Закрепить меню",


    "mainHeaderNavCompany": "Компания",
    "mainHeaderNavProduct": "Продукт",
    "mainHeaderNavAdvantages": "Преимущества",
    "mainHeaderNavTools": "Инструменты",
    "mainHeaderGetStartedButton": "Начать Бесплатно",

    "mainPageTH1": "Расскройте своё",
    "mainPageTH2": "величие",
    "mainPageTH3": "с волшебной документацией",
    "mainPageP1H1": "Раскройте секреты цифровой алхимии и станьте волшебником веб разработки, способным создавать",
    "mainPageP1H2": "потрясающие веб-сайты",
    "mainPageP1H3": "которые бросают вызов логике и очаровывают всех, кто их посещает.",
    "mainPageShortSlogan": "Раскройте весь свой потенциал уже сегодня",
    "mainPageNoCredit": "Никакие Кредитные или Дебитовые карты не требуются",
    "mainPageGetStartedButton": "Учиться Бесплатно",

    "whyNoushiTH1": "Почему вы выбераете",
    "whyNoushiTH2": "Noushi",
    "whyNoushiP1": "Наш сайт сам по себе служит наглядным примером эффективного веб-дизайна, вдохновляя пользователей и демонстрируя потенциал их собственных творений",
    "whyNoushiCardFirstT": "Подробное Руководство",
    "whyNoushiCardFirstP1": "Наш сайт предлагает исчерпывающие учебные пособия, которые охватывают различные аспекты веб-дизайна, предоставляя пользователям полный опыт обучения",
    "whyNoushiCardSecondT": "Для Начинающих",
    "whyNoushiCardSecondP1": "Наши учебные пособия предназначены для начинающих, предоставляя пошаговые инструкции и рекомендации, которые помогут вам понять мир веб-дизайна и ориентироваться в нем",
    "whyNoushiCardThirdT": "Регулярные Обновления",
    "whyNoushiCardThirdP1": "Мы следим за последними достижениями в области веб-дизайна и регулярно обновляем наш контент, чтобы гарантировать пользователям доступ к наиболее актуальной и передовой информации",

    "mainFirstInfoBlockT1": "Вас тоже приводит в бешенство невероятное количество воды при поиске информации?",
    "mainFirstInfoBlockP1": "С нашим продуктом вам не придется проходить через этот ад. Вы сможете получить знания легко и просто",
    "mainFirstInfoBlockT2": "Взгляните на то, чем мы гордимся",
    "mainFirstInfoBlockListElem1": "Никакой воды, только нужная информация",
    "mainFirstInfoBlockListElem2": "Информация структурирована и разделена по темам",
    "mainFirstInfoBlockListElem3": "Примеры кода и его визуализация",
    "mainFirstInfoBlockListElem4": "Весь необходимый минимум можно освоить за считанные мгновения",
    "mainFirstInfoBlockGetStartedButton": "Начать Использовать",


    "mainSecondInfoBlockT1": "Вы устали от неудобных документаций?",
    "mainSecondInfoBlockP1": "Мы заботимся о вашем комфорте и хотим, чтобы вам нравилось пользоваться нашей документацией. Мы помним, что удобство кроется в мелочах",
    "mainSecondInfoBlockT2": "Мы заботимся о вас",
    "mainSecondInfoBlockListElem1": "Простой и интуитивно понятный дизайн документации",
    "mainSecondInfoBlockListElem2": "Перевод на разные языки, чтобы больше людей могли комфортно учиться",
    "mainSecondInfoBlockListElem3": "Различные цветовые темы, чтобы вы могли выбрать ту, которая вам нравится лично вам",
    "mainSecondInfoBlockListElem4": "Простой и понятный стиль письма",
    "mainSecondInfoBlockGetStartedButton": "Начать Использовать",

    "footerGetStartedButton": "Начать Бесплатно",


    "introductionToHTMLT": "Введение в HTML",
    "definitionT": "Определение",
    "definitionP1": "HTML (HyperText Markup Language) это язык гипертекстовой разметки. По простому это значит, что он нужен для добавления каких-либо элементов на страницу, будь-то текст, картинки, кнопки, поля ввода и др",
    "tagT": "Тег",
    "tagP1": "Тег это определённый элемент на странице. Мы можем представить нашу страницу в браузере в виде дома, тогда теги это его составляющие, такие так дверь, окна, стены, крыша и тд. Тег выглядит так:",
    "tagCon1": "Содержимое тега",
    "tagP2": "Как мы видим, тег это своего рода \"обёртка\" вокруг содержимого. Он состоит из двух частей: открывающей(<>) и закрывающей(</>). Но так же существуют одинарные теги, которые закрывают сами себя:",
    "attrT": "Атрибут",
    "attrP1": "Атрибуты можно назвать свойствами частей нашего домика. Например, если это дверь, она может быть входной или межкомнатной, может быть металлической, а может деревянной и тд. У одного тега может быть сколь угодно много атрибутов. Так выглядит синтаксис:",
    "doctypeT": "Doctype",
    "doctypeP1": "У любого html файла есть определённый шаблон, фундамент, который выглядит следующим образом:",
    "doctypeP2": "Не усложняйте себе жизнь, пытаясь сразу здесь разобраться. Запомните - основное содержимое страницы пишется в теге <body>, а в теге <head> есть всего пару тегов, которые могут вам понадобиться на первых порах",

    "tagsInHeadT": "Теги в <head>",
    "watchAndForgetT": "Увидеть и забыть",
    "watchAndForgetP1": "Я предлагаю быстро взглянуть на полезные теги, внутри тега <head> и никогда больше к ним не возвращаться",
    "titleT": "<title>",
    "titleP1": "Содержимое тега <title> не выводится на страницу. Это текст, который мы видим сверху, рядом с вкладкой в браузере",
    "linkT": "<link>",
    "linkP1": "Многофункциональный тег, служащий для подключения к нашей странице CSS-стилей, favicon`а, шрифтов и др. Атрибутом rel мы указывает тип подключаемого файла, а href указывает ссылку на файл",

    "textTagsT": "Текстовые теги",
    "headingsT": "Заголовки",
    "headingsP1": "Заголовки бывают шести типов, от <h1> до <h6>. На практике больше первых трёх-четырёх заголовков применяются очень редко",
    "paragraphT": "Абзац",
    "paragraphP1": "Абзац это стандартный текстовый элемент, служащий для добавления простого текста",
    "spanT": "<span>",
    "spanP1": "По сути ничего из себя не представляет. Обычно используется внутри друго текстового тега, для стилизации отдельных его частей",
    "textLinkT": "Ссылка",
    "textLinkP1": "Ссылка служит для перехода на другой сайт или другую страницу текущего сайта. Сама ссылка указывается в атрибуте href. На моменте разработки может понадобится добавить ссылку, которая никуда не ведёт. Тогда значением href следует указать #. Также следует заметить, хоть мы и добавили <a> в раздел к текстовым тегам, внутрь него можно обернуть что угодно, например сделать картинку-ссылку",

    "listsT": "Списки",
    "orderedListT": "<ol>",
    "orderedListP1": "Упорядоченный список, он же нумерованный",
    "unorderedListT": "<ul>",
    "unorderedListP1": "Неупорядоченый список выглядит как простой список без нумерации",
    "liT": "<li>",
    "liP1": "<li> это элемент списка, пункт",

    "blockElementsT": "Блоковые элементы",
    "blockElementsIntroductoryInformationT": "Вводная информация",
    "blockElementsIntroductoryInformationP1": "Сами по себе блоковые теги ничего из себя не представляют. Это просто контейнеры. Тем не менее, умение использовать и комбинировать их критически важно при вёрстке",
    "divT": "<div>",
    "divP1": "Это основной блоковый элемент в HTML. По сути, все остальные блоковые элементы это копии div, но только с семантической окраской, так что весь сайт можно построить пользуясь только им. Но всё же, по возможности используйте его семантические версии",
    "headerT": "<header>",
    "headerP1": "Шапка страницы или блока, верхняя часть. Обычно повторяется на других страницах сайта",
    "footerT": "<footer>",
    "footerP1": "Подвал страницы или блока, нижняя часть. Обычно повторяется на других страницах сайта",
    "sectionT": "<section>",
    "sectionP1": "Неотделяемый смысловой блок на странице",
    "asideT": "<aside>",
    "asideP1": "Побочный, обособленный блок на странице",
    "articleT": "<article>",
    "articleP1": "Как и <section> это смысловой блок на странице, но отделяемый",
    "mainT": "<main>",
    "mainP1": "Основная суть страницы, нигде не повторяющаяся",
    "navT": "<nav>",
    "navP1": "Навигация по сайту. Обычно содержит ссылки на другие страницы",

    "inputsT": "Ввод",
    "inputsIntroductoryInformationT": "Вводная информация",
    "inputsIntroductoryInformationP1": "Тег <input> предназначен для взаимодействия с пользователем и получения от него информации. <input> может выглядеть совершенно по разному. Необходимый нам тип мы указываем атрибутом type. По умолчанию type указан text. Также необходимо указывать атрибут name для корректной отправки на сервер",
    "valueAndPlaceholderT": "Атрибуты value и placeholder",
    "valueAndPlaceholderP1": "Атрибут value задаёт значение по умолчанию для формы, а placeholder даёт подсказку пользователю, что необходимо ввести в поле",
    "formT": "<form>",
    "formP1": "В нативном HTML все input что мы будем добавлять на сайт должны находиться в блоковом элементе <form>. Это необходимо для корректной отправки данных на сервер",
    "inputTextT": "<input type=\"text\">",
    "inputTextP1": "Простая строка ввода",
    "inputTextC": "Введите что-нибудь",
    "inputPasswordT": "<input type=\"password\">",
    "inputPasswordP1": "Строка, но со звёздочками вместо букв",
    "inputPasswordC": "Введите пароль",
    "inputRadioT": "<input type=\"radio\">",
    "inputRadioP1": "Переключатели. Можно выбрать только один вариант",
    "inputCheckboxT": "<input type=\"checkbox\">",
    "inputCheckboxP1": "Флажки. Позволяют выбрать более одного варианта",
    "inputButtonT": "<input type=\"button\">",
    "inputButtonP1": "Простая кнопка. name указывать не нужно, поскольку он этот input не содержит данных",
    "inputButtonC": "Просто кнопка",
    "inputSubmitT": "<input type=\"submit\">",
    "inputSubmitP1": "Кнопка отправки данных на сервер. name указывать не нужно, поскольку он этот input не содержит данных",

    "otherTagsT": "Прочие теги",
    "imgT": "<img>",
    "imgP1": "Добавляет картинку на сайт. В атрибуте src указывается путь до изображения, а в атрибуте alt указывается текст, который будет показан в случае неуспешного добавления картинки",
    "buttonT": "<button>",
    "buttonP1": "Продвинутый аналог <input type=\"button\">. Позволяет сделать кнопкой что угодно",

    "styleAttrsT": "Атрибуты для стилизации",
    "classT": "class",
    "classP1": "Добавляет класс к элементу, по которому можно к нему обратиться из CSS",
    "idT": "id",
    "idP1": "Добавляет идентификатор к элементу, по которому можно к нему обратиться из CSS. Но лучше так не делать",
    "styleT": "style",
    "styleP1": "Позволяет добавлять стили напрямую к элементу из HTML. Лучше стараться не использовать",


    "selectorsT": "Селекторы",
    "selectorsIntroductoryInformationT": "Вводная информация",
    "selectorsIntroductoryInformationP1": "Селекторы - это шаблоны, которые используются для привязки стилевых свойств к элементам в документе",
    "selectorsIntroductoryInformationP2": "У всех селекторов есть свой вес. Чем больше вес, тем главнее селектор. Вес каждого селектора зубрить смысла нет. Просто задумайтесь у какого селектора меньше выборка. Чем меньше выборка - тем больше вес",
    "typeSelectorsT": "Селекторы типа",
    "typeSelectorsP1": "Селекторы типа это самые простые селекторы из возможных. Выбирают все элементы на странице определённого тега. Следовательно имеют очень маленький вес",
    "typeSelectorsC": "Стили будут применены ко всем <p> на странице",
    "classSelectorsT": "Селекторы класса",
    "classSelectorsP1": "Селекторы класса более продвинутые селекторы. Выбирают все элементы на странице определённого класса. Имеют средний вес",
    "classSelectorsC": "Стили будут применены ко всем элементом с классом title на странице",
    "idSelectorsT": "Селекторы идентификатора",
    "idSelectorsP1": "Селектор идентификатора выбирает один элемент на странице по уникальному id. Из-за такой маленькой выборки имеют огромный вес который очень сложно перебить. Использование селекторов идентификатора сегодня считается плохой практикой",
    "idSelectorsC": "Стили будут применены к одному элементу с идентификатором button",
    "attributeSelectorsT": "Селекторы наличия и значения атрибута",
    "attributeSelectorsP1": "Селекторы наличия и значения атрибута выбирают все элементы по определённому атрибуту и его значению. Очень часто их можно встретить при стилизации input",
    "attributeSelectorsC": "Стили будут применены ко всем input на странице для которых установлен атрибут type=\"radio\"",
    "universalSelectorT": "Универсальный селектор",
    "universalSelectorP1": "Универсальный селектор добавляет стили для всех элементов на странице",
    "universalSelectorC": "Стили будут применены ко всем элементам на странице",
    "neighboringRelatedCombinatorT": "Соседний родственный комбинатор",
    "neighboringRelatedCombinatorP1": "Выглядит как selector1 + selector2. Стили будут применены ко всем элементам, проходящих выборку selector2, перед которыми в DOM-дереве находится элемент, проходящих выборку selector1. Часто можно встретить при стилизации списков",
    "neighboringRelatedCombinatorC": "Стили будут применены ко всем тегам <li>, перед которыми есть другой тег",
    "childCombinatorT": "Дочерний комбинатор",
    "childCombinatorP1": "Выглядит как selector1 > selector2. Стили будут применены ко всем элементам, проходящих выборку selector2, являющихся прямыми потомками элементов, проходящих выборку selector1. Встречается нечасто",
    "childCombinatorC": "Стили будут применены ко всем тегам <p>, которые являются детьми первого уровня элементов с классом container",
    "commonRelatedCombinatorT": "Общий родственный комбинатор",
    "commonRelatedCombinatorP1": "Выглядит как selector1 ~ selector2. Стили будут применены ко всем элементам, проходящих выборку selector2, перед которыми в DOM-дереве находится элемент, проходящих выборку selector1. Оба элемента должны принадлежать одному родителю. Этот селектор отличается от соседнего селектора тем, что между элементами selector1 и selector2 могут находиться другие элементы. Встречается нечасто",
    "commonRelatedCombinatorC": "Стили будут применены ко всем тегам <p> кроме первого, которые являются детьми первого уровня элементов с классом container",
    "descendantCombinatorT": "Комбинатор потомка",
    "descendantCombinatorP1": "Выглядит как selector1 selector2. Находит все соответствующие selector2 потомки элемента, который подходит под selector1, и применяет к ним стили. Используется повсеместно",
    "descendantCombinatorC": "Стили будут применены ко всем тегам <p> внутри тегов <div>",

    "measurementUnitsT": "Единицы измерения",
    "pixelsT": "Пиксели",
    "pixelsP1": "px - наиболее распространенная единица измерения, которая определяет размеры элементов на экране. Один пиксель представляет собой наименьшую отдельную точку на экране",
    "percentsT": "Проценты",
    "percentsP1": "% - используются для определения размеров элементов относительно размера родительского элемента или контейнера",
    "emAndRemT": "em и rem",
    "emAndRemP1": "em - относительная единица измерения, которая зависит от размера шрифта родительского элемента. Значение 1em равно текущему размеру шрифта. rem аналогичен единице измерения EM, но значение 1rem всегда равно размеру шрифта корневого элемента (обычно это <html>)",
    "viewportT": "Вьюпорт",
    "viewportP1": "vw и vh - относительные единицы измерения, которые определяются относительно размеров видимой области (viewport) браузера. 1vw равен 1% ширины видимой области, а 1vh равен 1% высоты видимой области",

    "pseudoClassesT": "Псевдоклассы",
    "pseudoClassesIntroductoryInformationT": "Вводная информация",
    "pseudoClassesIntroductoryInformationP1": "Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние",
    "hoverP1": ":hover применяется к элементу при наведении на него курсора мыши",
    "hoverC": "Стили будут применены к <button> при наведении на неё мыши",
    "activeP1": ":active применяется к элементу во время нажатия на него",
    "activeC": "Стили будут применены к <button> при нажатии на неё",
    "focusP1": ":focus применяется к элементу, который находится в фокусе (например, при клике на текстовое поле)",
    "focusC": "Стили будут применены к <button> в фокусе (например выбор кнопки через Tab)",
    "visitedP1": ":visited применяется к посещенным ссылкам",
    "visitedC": "Стили будут применены ко всем посещённым ссылкам",

    "pseudoElementsT": "Псевдоэлементы",
    "pseudoElementsIntroductoryInformationT": "Вводная информация",
    "pseudoElementsIntroductoryInformationP1": "Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть выбранного элемента",
    "beforeP1": "::before добавляет контент перед содержимым выбранного элемента. Работает совместно со свойством content",
    "beforeC": "Перед элементами списка будет выводиться знак доллара",
    "afterP1": "::after добавляет контент после содержимого выбранного элемента. Работает совместно со свойством content",
    "afterC": "После элементов списка будет выводиться знак амперсанда",
    "placeholderP1": "::placeholder применяется к плейсхолдеру внутри текстового поля или текстового поля с маской",
    "placeholderC": "Стили будут применены к placeholder всех <input> c type=\"text\"",

    "mathematicsT": "Математика",
    "calcP1": "calc() позволяет добавить на сайт простейшую математику. Мы можем складывать(+), вычитать(-), умножать(*) и делить(/) разные единицы измерения. Во всех остальных математических функциях мы также можем использовать эти операторы",
    "minAndMaxT": "min и max",
    "minAndMaxP1": "min(a, b) и max(a, b) выбирает минимальное и максимальное из двух значений соответственно. Являются важными знаниями при адаптивной вёрстке",
    "clampP1": "clamp(a, b, c) можно представить в виде желаемого значения, ограниченного минимальным и максимальным значением. Тоже крайне нужная вещь при построении адаптива",

    "sizesT": "Размеры",
    "heightAndWidthT": "height и width",
    "heightAndWidthP1": "height - высота, width - ширина",
    "maxHeightMinHeightAndMaxWidthMinWidthT": "max-height, min-height и max-width, min-width",
    "maxHeightMinHeightAndMaxWidthMinWidthP1": "По логике - значения максимальной/минимальной высоты/ширины",

    "textT": "Текст",
    "fontFamilyP1": "font-family задаёт шрифт текста. Возможно указать несколько значений, шрифты в начале имеют больший приоритет. Также имеются стандартные значения serif и sans-serif, которые гарантированно есть на всех устройствах",
    "fontSizeP1": "font-size задаёт размер шрифта",
    "fontWeightP1": "font-weight определяет толщину шрифта. Можно указывать значение словами normal, bold и др. Но я предпочитаю использовать числовые значения: 100, 200, 300... 900. От 100 до 900 с шагом в сотню. Указывать единицы измерения не нужно. Ещё следует заметить, что далеко не все шрифты имеют начертания всех типов",
    "textAlignP1": "text-align это выравнивание текста по одному из краев. Для счастливой жизни достаточно знать left, right, center и justify",
    "textShadowP1": "text-shadow добавляет тень для текста. Указывается цвет и три числовых значения по порядку: сдвиг по X, сдвиг по Y и степень размытия",
    "textDecorationP1": "text-decoration подчёркивает(underline), зачёркивает(line-through) или надчёркивает(overline) текст",

    "colorAndBackgroundT": "Цвет и фон",
    "colorIndicationFormatsT": "Форматы указания цвета",
    "colorIndicationFormatsP1": "Именованные цвета - предопределенные названия цветов, такие как \"red\", \"blue\", \"green\" и т. д.",
    "colorIndicationFormatsP2": "HEX-коды - шестнадцатеричное представление цвета, состоящее из символов 0-9 и A-F. Например, \"#FF0000\" представляет красный цвет",
    "colorIndicationFormatsP3": "RGB - представление цвета в виде комбинации значений красного (R), зеленого (G) и синего (B) компонентов. Например, \"rgb(255, 0, 0)\" представляет красный цвет.",
    "colorIndicationFormatsP4": "RGBA - аналогично RGB, но с добавлением альфа-канала, который определяет прозрачность цвета. Например, \"rgba(255, 0, 0, 0.5)\" представляет полупрозрачный красный цвет.",
    "colorIndicationFormatsP5": "CSS3 цветовые функции - CSS3 предоставляет функции для создания цветов, такие как linear-gradient() и radial-gradient(). Эти функции позволяют создавать градиенты и другие сложные эффекты цвета.",
    "colorP1": "color задаёт цвет для текста",
    "backgroundColorP1": "background-color задаёт цвет для фона элемента",
    "backgroundGradientP1": "background: linear-gradient() позволяет задать градиент для фона. В базовом варианте первым аргументом указывается наклон в градусах, а далее цвета градиента",
    "backgroundImageP1": "background-image задаёт элементу фоновое изображение через url(\"URL\")",
    "backgroundAttachmentP1": "background-attachment устанавливает, будет ли прокручиваться фоновое изображение вместе с содержимым элемента",
    "backgroundRepeatP1": "background-repeat устанавливает способ повторения заднего фона. Основные значения: repeat, round и no-repeat",
    "backgroundSizeP1": "background-size устанавливает размер заднего фона. Основные значения: contain, cover и произвольное значение",
    "backgroundPositionP1": "background-position устанавливает позицию заднего фона. Значения можно указывать словами, а можно произвольно",

    "displayFlexP1": "display: flex позволяет сделать элементы в блоке обтекаемыми, а также даёт доступ к другим flex-свойствам. Для сравнения стандартное значение block",
    "flexDirectionP1": "С помощью flex-direction мы можем указать направление укладки элементов",
    "flexWrapP1": "flex-wrap отвечает за перенос элементов",
    "justifyContentP1": "justify-content отвечает за размещение элементов в блоке. Самые часто используемые значения это center, space-between и space-around",

    "displayGridT1": "display: grid, grid-template-columns, grid-template-rows и единица измерения fr",
    "displayGridP1": "display: grid ведёт себя как display: block, но открывает доступ к интересным CSS-свойствам, которые позволяют создать сетку(grid) на странице, а также к единице измерения fr. fr можно условно назвать \"часть\". Запись repeat(3, 1fr) означает \"поделить блок на 3 равные части\". repeat(5, 1fr) соответственно \"поделить блок на 5 равных частей\". 30% 60% 1fr знает что всё доступное пространство делится на 3 неравные части. Одна часть занимает 30%, вторая часть 60%, а третья то, что останется. В данном примере это 10%.",
    "displayGridP2": "grid-template-columns и grid-template-rows соответственно означают деление на столбики и строки. Получается что-то вроде таблицы",
    "gridAreasT": "grid-template-areas и grid-area",
    "gridAreasP1": "grid-template-areas это общее свойство для колонок и строк. Имеет специфический синтаксис, но позволяет задавать нестандартную сетку. Для маркировки элементов сетки используется grid-area",
    "gapP1": "gap это зазоры между элементами сетки, но далеко не всегда они работают так, как нам хочется",

    "displayNoneP1": "display: none полностью убирает блок со страницы так, будто его и нет",
    "displayNoneC": "Нажатие кнопки добавляет и убирает display: none",
    "displayNoneB1": "Скрыть/показать",
    "displayBlockP1": "display: block Значение display по умолчанию. Ничего интересного",

    "positionP1": "position устанавливает способ позиционирования элемента относительно окна браузера или других объектов на веб-странице. Значение по умолчанию static. Самые распространённые значения absolute, relative и fixed. Все они открывают новые свойства left, top, right и bottom. Это своего рода отступы с определённой стороны. От значения position зависит относительно чего будут отступы.",
    "positionAbsoluteP1": "absolute - отступы относительно начала координат на странице (левого верхнего угла), но если поместить такой элемент внутрь элемента relative, то позиционирование будет происходить относительно родительского элемента. Помимо этого элемент с position: absolute становится бестелесным и неосязаемым.",
    "positionRelativeP1": "relative - отступы относительно самого себя. Бестелесным элемент не становится, но его тело не перемещается",
    "positionFixedP1": "fixed - похож на absolute, но привязывается к определённому положению на экране",

    "transformP1": "transform это обширное CSS-свойство, которое включает в себя массу значений позволяющих перемещать элемент, вращать, маштабировать и тд. Но распространённых всего несколько: translate(x, y), rotate(deg) и scale(x, y). Есть также производные от них: translateX(x), translateY(y), scaleX(x) и тд. Остальные значения почти не используются",
    "transformTranslateP1": "transform: translate() по сути очень напоминает position: relative. Тоже позволяет нам сдвигать элементы относительно себя",
    "transformRotateP1": "transform: rotate() позволяет нам вращать элементы на странице",
    "transformScaleP1": "transform: scale() изменяет размер элемента по осям",

    "animationT": "Анимация",
    "transitionP1": "transition позволяет добавить плавное изменение CSS-свойства. Указывается необходимое свойство (можно указать all), а также время в миллисекундах или секундах. Можно указать задержку перед началом анимации и кривую анимации",
    "keyframesAndAnimationT": "@keyframes и animation",
    "keyframesAndAnimationP1": "@keyframes позволяет нам создать анимацию с помощью ключевых кадров и дать ей название. Ключевые кадры задаются процентами от анимации. С помощью animation мы применяем созданную анимацию и указываем дополнительные параметры, такие как время, задержка, кривая анимации, повторяемость и др",
    "keyframesAndAnimationP2": "Для интереса, примерно так реализован градиент:",

    "framesT": "Рамки",
    "borderP1": "border добавляет осязаемую рамку элементу, которая является его частью. Указывается толщина рамки, цвет и стиль рамки. В 90% случаев достаточно сплошной рамки solid",
    "outlineP1": "outline добавляет неосязаемую рамку элементу, которая не является его частью. Указывается толщина рамки, цвет и стиль рамки. В 90% случаев достаточно сплошной рамки solid",
    "borderRadiusP1": "border-radius скругляет края элемента",

    "indentsT": "Отступы",
    "paddingP1": "padding добавляет внутренние отступы для элемента",
    "marginP1": "margin добавляет внешние отступы для элемента",
    "marginP2": "Значение auto можно использовать как метод центрирования",

    "otherT": "Прочее",
    "zIndexP1": "z-index это аналог слоёв в фотошопе. Чем больше значение, тем выше слой",
    "zIndexC": "Кнопки меняют значение",
    "boxShadowP1": "box-shadow это копия text-shadow, но для блочных элементов",
    "opacityP1": "opacity - непрозрачность",
    "alignItemsP1": "align-items выравнивает элементы в блоке. Обычно используется только center",
    "cursorP1": "cursor обозначает тип указателя мыши при наведении",
    "visibilityP1": "visibility: hidden скрывает элемент на странице, но место занимаемое им остаётся занятым. Возможно анимировать",
    "listStyle": "list-style настраивает стиль указателей списка. Можно выбрать из множества существующих, а можно указать самому"
  }
}