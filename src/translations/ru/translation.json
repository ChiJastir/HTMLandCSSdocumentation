{
  "translation": {
    "settings": "Настройки",
    "theme": "Тема",
    "language": "Язык",

    "cssNav": "Навигация по CSS",

    "selectorsT": "Селекторы",
    "selectorsIntroductoryInformationT": "Вводная информация",
    "selectorsIntroductoryInformationP1": "Селекторы - это шаблоны, которые используются для привязки стилевых свойств к элементам в документе",
    "selectorsIntroductoryInformationP2": "У всех селекторов есть свой вес. Чем больше вес, тем главнее селектор. Вес каждого селектора зубрить смысла нет. Просто задумайтесь у какого селектора меньше выборка. Чем меньше выборка - тем больше вес",
    "typeSelectorsT": "Селекторы типа",
    "typeSelectorsP1": "Селекторы типа это самые простые селекторы из возможных. Выбирают все элементы на странице определённого тэга. Следовательно имеют очень маленький вес",
    "typeSelectorsC": "Стили будут применены ко всем <p> на странице",
    "classSelectorsT": "Селекторы класса",
    "classSelectorsP1": "Селекторы класса более продвинутые селекторы. Выбирают все элементы на странице определённого класса. Имеют средний вес",
    "classSelectorsC": "Стили будут применены ко всем элементом с классом title на странице",
    "idSelectorsT": "Селекторы идентификатора",
    "idSelectorsP1": "Селектор идентификатора выбирает один элемент на странице по уникальному id. Из-за такой маленькой выборки имеют огромный вес который очень сложно перебить. Использование селекторов идентификатора сегодня считается плохой практикой",
    "idSelectorsC": "Стили будут применены к одному элементу с идентификатором button",
    "attributeSelectorsT": "Селекторы наличия и значения атрибута",
    "attributeSelectorsP1": "Селекторы наличия и значения атрибута выбирают все элементы по определённому атрибуту и его значению. Очень часто их можно встретить при стилизации input",
    "attributeSelectorsC": "Стили будут применены ко всем input на странице для которых установлен атрибут type=\"radio\"",
    "universalSelectorT": "Универсальный селектор",
    "universalSelectorP1": "Универсальный селектор добавляет стили для всех элементов на странице",
    "universalSelectorC": "Стили будут применены ко всем элементам на странице",
    "neighboringRelatedCombinatorT": "Соседний родственный комбинатор",
    "neighboringRelatedCombinatorP1": "Выглядит как selector1 + selector2. Стили будут применены ко всем элементам, проходящих выборку selector2, перед которыми в DOM-дереве находится элемент, проходящих выборку selector1. Часто можно встретить при стилизации списков",
    "neighboringRelatedCombinatorC": "Стили будут применены ко всем тэгам <li>, перед которыми есть другой тэг",
    "childCombinatorT": "Дочерний комбинатор",
    "childCombinatorP1": "Выглядит как selector1 > selector2. Стили будут применены ко всем элементам, проходящих выборку selector2, являющихся прямыми потомками элементов, проходящих выборку selector1. Встречается нечасто",
    "childCombinatorC": "Стили будут применены ко всем тэгам <p>, которые являются детьми первого уровня элементов с классом container",
    "commonRelatedCombinatorT": "Общий родственный комбинатор",
    "commonRelatedCombinatorP1": "Выглядит как selector1 ~ selector2. Стили будут применены ко всем элементам, проходящих выборку selector2, перед которыми в DOM-дереве находится элемент, проходящих выборку selector1. Оба элемента должны принадлежать одному родителю. Этот селектор отличается от соседнего селектора тем, что между элементами selector1 и selector2 могут находиться другие элементы. Встречается нечасто",
    "commonRelatedCombinatorC": "Стили будут применены ко всем тэгам <p> кроме первого, которые являются детьми первого уровня элементов с классом container",
    "descendantCombinatorT": "Комбинатор потомка",
    "descendantCombinatorP1": "Выглядит как selector1 selector2. Находит все соответствующие selector2 потомки элемента, который подходит под selector1, и применяет к ним стили. Используется повсеместно",
    "descendantCombinatorC": "Стили будут применены ко всем тэгам <p> внутри тэгов <div>",

    "measurementUnitsT": "Единицы измерения",
    "pixelsT": "Пиксели",
    "pixelsP1": "px - наиболее распространенная единица измерения, которая определяет размеры элементов на экране. Один пиксель представляет собой наименьшую отдельную точку на экране",
    "percentsT": "Проценты",
    "percentsP1": "% - используются для определения размеров элементов относительно размера родительского элемента или контейнера",
    "emAndRemT": "em и rem",
    "emAndRemP1": "em - относительная единица измерения, которая зависит от размера шрифта родительского элемента. Значение 1em равно текущему размеру шрифта. rem аналогичен единице измерения EM, но значение 1rem всегда равно размеру шрифта корневого элемента (обычно это <html>)",
    "viewportT": "Вьюпорт",
    "viewportP1": "vw и vh - относительные единицы измерения, которые определяются относительно размеров видимой области (viewport) браузера. 1vw равен 1% ширины видимой области, а 1vh равен 1% высоты видимой области",

    "pseudoClassesT": "Псевдоклассы",
    "pseudoClassesIntroductoryInformationT": "Вводная информация",
    "pseudoClassesIntroductoryInformationP1": "Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние",
    "hoverP1": ":hover применяется к элементу при наведении на него курсора мыши",
    "hoverC": "Стили будут применены к <button> при наведении на неё мыши",
    "activeP1": ":active применяется к элементу во время нажатия на него",
    "activeC": "Стили будут применены к <button> при нажатии на неё",
    "focusP1": ":focus применяется к элементу, который находится в фокусе (например, при клике на текстовое поле)",
    "focusC": "Стили будут применены к <button> в фокусе (например выбор кнопки через Tab)",
    "visitedP1": ":visited применяется к посещенным ссылкам",
    "visitedC": "Стили будут применены ко всем посещённым ссылкам",

    "pseudoElementsT": "Псевдоэлементы",
    "pseudoElementsIntroductoryInformationT": "Вводная информация",
    "pseudoElementsIntroductoryInformationP1": "Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть выбранного элемента",
    "beforeP1": "::before добавляет контент перед содержимым выбранного элемента. Работает совместно со свойством content",
    "beforeC": "Перед элементами списка будет выводиться знак доллара",
    "afterP1": "::after добавляет контент после содержимого выбранного элемента. Работает совместно со свойством content",
    "afterC": "После элементов списка будет выводиться знак амперсанда",
    "placeholderP1": "::placeholder применяется к плейсхолдеру внутри текстового поля или текстового поля с маской",
    "placeholderC": "Стили будут применены к placeholder всех <input> c type=\"text\"",

    "mathematicsT": "Математика",
    "calcP1": "calc() позволяет добавить на сайт простейшую математику. Мы можем складывать(+), вычитать(-), умножать(*) и делить(/) разные единицы измерения. Во всех остальных математических функциях мы также можем использовать эти операторы",
    "minAndMaxT": "min и max",
    "minAndMaxP1": "min(a, b) и max(a, b) выбирает минимальное и максимальное из двух значений соответственно. Являются важными знаниями при адаптивной вёрстке",
    "clampP1": "clamp(a, b, c) можно представить в виде желаемого значения, ограниченного минимальным и максимальным значением. Тоже крайне нужная вещь при построении адаптива",

    "sizesT": "Размеры",
    "heightAndWidthT": "height и width",
    "heightAndWidthP1": "height - высота, width - ширина",
    "maxHeightMinHeightAndMaxWidthMinWidthT": "max-height, min-height и max-width, min-width",
    "maxHeightMinHeightAndMaxWidthMinWidthP1": "По логике - значения максимальной/минимальной высоты/ширины",

    "textT": "Текст",
    "fontFamilyP1": "font-family задаёт шрифт текста. Возможно указать несколько значений, шрифты в начале имеют больший приоритет. Также имеются стандартные значения serif и sans-serif, которые гарантированно есть на всех устройствах",
    "fontSizeP1": "font-size задаёт размер шрифта",
    "fontWeightP1": "font-weight определяет толщину шрифта. Можно указывать значение словами normal, bold и др. Но я предпочитаю использовать числовые значения: 100, 200, 300... 900. От 100 до 900 с шагом в сотню. Указывать единицы измерения не нужно. Ещё следует заметить, что далеко не все шрифты имеют начертания всех типов",
    "textAlignP1": "text-align это выравнивание текста по одному из краев. Для счастливой жизни достаточно знать left, right, center и justify",
    "textShadowP1": "text-shadow добавляет тень для текста. Указывается цвет и три числовых значения по порядку: сдвиг по X, сдвиг по Y и степень размытия",
    "textDecorationP1": "text-decoration подчёркивает(underline), зачёркивает(line-through) или надчёркивает(overline) текст",

    "colorAndBackgroundT": "Цвет и фон",
    "colorIndicationFormatsT": "Форматы указания цвета",
    "colorIndicationFormatsP1": "Именованные цвета - предопределенные названия цветов, такие как \"red\", \"blue\", \"green\" и т. д.",
    "colorIndicationFormatsP2": "HEX-коды - шестнадцатеричное представление цвета, состоящее из символов 0-9 и A-F. Например, \"#FF0000\" представляет красный цвет",
    "colorIndicationFormatsP3": "RGB - представление цвета в виде комбинации значений красного (R), зеленого (G) и синего (B) компонентов. Например, \"rgb(255, 0, 0)\" представляет красный цвет.",
    "colorIndicationFormatsP4": "RGBA - аналогично RGB, но с добавлением альфа-канала, который определяет прозрачность цвета. Например, \"rgba(255, 0, 0, 0.5)\" представляет полупрозрачный красный цвет.",
    "colorIndicationFormatsP5": "CSS3 цветовые функции - CSS3 предоставляет функции для создания цветов, такие как linear-gradient() и radial-gradient(). Эти функции позволяют создавать градиенты и другие сложные эффекты цвета.",
    "colorP1": "color задаёт цвет для текста",
    "backgroundColorP1": "background-color задаёт цвет для фона элемента",
    "backgroundImageP1": "background-image задаёт элементу фоновое изображение через url(\"URL\")",
    "backgroundAttachmentP1": "background-attachment устанавливает, будет ли прокручиваться фоновое изображение вместе с содержимым элемента",
    "backgroundRepeatP1": "background-repeat устанавливает способ повторения заднего фона. Основные значения: repeat, round и no-repeat",
    "backgroundSizeP1": "background-size устанавливает размер заднего фона. Основные значения: contain, cover и произвольное значение",
    "backgroundPositionP1": "background-position устанавливает позицию заднего фона. Значения можно указывать словами, а можно произвольно",

    "displayFlexP1": "display: flex позволяет сделать элементы в блоке обтекаемыми, а также даёт доступ к другим flex-свойствам. Для сравнения стандартное значение block",
    "flexDirectionP1": "С помощью flex-direction мы можем указать направление укладки элементов",
    "flexWrapP1": "flex-wrap отвечает за перенос элементов",
    "justifyContentP1": "justify-content отвечает за размещение элементов в блоке. Самые часто используемые значения это center, space-between и space-around",

    "displayGridT1": "display: grid, grid-template-columns, grid-template-rows и единица измерения fr",
    "displayGridP1": "display: grid ведёт себя как display: block, но открывает доступ к интересным CSS-свойствам, которые позволяют создать сетку(grid) на странице, а также к единице измерения fr. fr можно условно назвать \"часть\". Запись repeat(3, 1fr) означает \"поделить блок на 3 равные части\". repeat(5, 1fr) соответственно \"поделить блок на 5 равных частей\". 30% 60% 1fr знает что всё доступное пространство делится на 3 неравные части. Одна часть занимает 30%, вторая часть 60%, а третья то, что останется. В данном примере это 10%.",
    "displayGridP2": "grid-template-columns и grid-template-rows соответственно означают деление на столбики и строки. Получается что-то вроде таблицы",
    "gridAreasT": "grid-template-areas и grid-area",
    "gridAreasP1": "grid-template-areas это общее свойство для колонок и строк. Имеет специфический синтаксис, но позволяет задавать нестандартную сетку. Для маркировки элементов сетки используется grid-area",
    "gapP1": "gap это зазоры между элементами сетки, но далеко не всегда они работают так, как нам хочется",

    "displayNoneP1": "display: none полностью убирает блок со страницы так, будто его и нет",
    "displayNoneC": "Нажатие кнопки добавляет и убирает display: none",
    "displayNoneB1": "Скрыть/показать",
    "displayBlockP1": "display: block Значение display по умолчанию. Ничего интересного",

    "positionP1": "position устанавливает способ позиционирования элемента относительно окна браузера или других объектов на веб-странице. Значение по умолчанию static. Самые распространённые значения absolute, relative и fixed. Все они открывают новые свойства left, top, right и bottom. Это своего рода отступы с определённой стороны. От значения position зависит относительно чего будут отступы.",
    "positionAbsoluteP1": "absolute - отступы относительно начала координат на странице (левого верхнего угла), но если поместить такой элемент внутрь элемента relative, то позиционирование будет происходить относительно родительского элемента. Помимо этого элемент с position: absolute становится бестелесным и неосязаемым.",
    "positionRelativeP1": "relative - отступы относительно самого себя. Бестелесным элемент не становится, но его тело не перемещается",
    "positionFixedP1": "fixed - похож на absolute, но привязывается к определённому положению на экране",

    "transformP1": "transform это обширное CSS-свойство, которое включает в себя массу значений позволяющих перемещать элемент, вращать, маштабировать и тд. Но распространённых всего несколько: translate(x, y), rotate(deg) и scale(x, y). Есть также производные от них: translateX(x), translateY(y), scaleX(x) и тд. Остальные значения почти не используются",
    "transformTranslateP1": "transform: translate() по сути очень напоминает position: relative. Тоже позволяет нам сдвигать элементы относительно себя",
    "transformRotateP1": "transform: rotate() позволяет нам вращать элементы на странице",
    "transformScaleP1": "transform: scale() изменяет размер элемента по осям",

    "AnimationT": "Анимация",
    "transitionP1": "transition позволяет добавить плавное изменение CSS-свойства. Указывается необходимое свойство (можно указать all), а также время в миллисекундах или секундах. Можно указать задержку перед началом анимации и кривую анимации",
    "keyframesAndAnimationT": "@keyframes и animation",
    "keyframesAndAnimationP1": "@keyframes позволяет нам создать анимацию с помощью ключевых кадров и дать ей название. Ключевые кадры задаются процентами от анимации. С помощью animation мы применяем созданную анимацию и указываем дополнительные параметры, такие как время, задержка, кривая анимации, повторяемость и др",
    "keyframesAndAnimationP2": "Для интереса, примерно так реализован градиент:",

    "framesT": "Рамки",
    "borderP1": "border добавляет осязаемую рамку элементу, которая является его частью. Указывается толщина рамки, цвет и стиль рамки. В 90% случаев достаточно сплошной рамки solid",
    "outlineP1": "outline добавляет неосязаемую рамку элементу, которая не является его частью. Указывается толщина рамки, цвет и стиль рамки. В 90% случаев достаточно сплошной рамки solid",
    "borderRadiusP1": "border-radius скругляет края элемента",

    "indentsT": "Отступы",
    "paddingP1": "padding добавляет внутренние отступы для элемента",
    "marginP1": "margin добавляет внешние отступы для элемента",
    "marginP2": "Значение auto можно использовать как метод центрирования",

    "otherT": "Прочее",
    "zIndexP1": "z-index это аналог слоёв в фотошопе. Чем больше значение, тем выше слой",
    "zIndexC": "Кнопки меняют значение",
    "boxShadowP1": "box-shadow это копия text-shadow, но для блочных элементов",
    "opacityP1": "opacity - непрозрачность",
    "alignItemsP1": "align-items выравнивает элементы в блоке. Обычно используется только center",
    "cursorP1": "cursor обозначает тип указателя мыши при наведении",
    "visibilityP1": "visibility: hidden скрывает элемент на странице, но место занимаемое им остаётся занятым. Возможно анимировать",
    "listStyle": "list-style настраивает стиль указателей списка. Можно выбрать из множества существующих, а можно указать самому"
  }
}